# Integer Representation

Integer representation is an abstraction that really matters here, the input to a neural
network is generally a flattened vector of floats. So the question is how do you map
integers to that format.

## Requirements

1. The representation has to be efficient in terms of space. Using one hot encoding for large integers is not feasible. Ideally logarithmic or polylogarithmic  in the integer value.

2. The representation has to be invertible, and efficiently so. A trivially "usable" representation is the integers as products of primes, multiplication is extremely easy, but the factorization step is not efficient.

Note that for invertibility we only care about going from an encoding to an integer, the reverse problem is less important.

## Examples

### Binary Representation

This is the most basic representation, which is to use binary encoding. Its the natural
representation for integers in computers and human created multiplication circuits.

For example you would encode the integer 13 as [1,1,0,1], and the integer 11 as [1,0,1,1].

And then you feed those vectors in directly as is.

This representation is really natural for computers, but I think for LLMs this might be a bit janky.

### Projected Representation

Projected representations are an object of study here, and will be used for something called slack variables.
The general idea is to take an existing representation, and project it into a different linear space.

For example in the binary case, maybe you take the 4 dimensional binary representation, and project it into
10 dimensions using orthogonal random vectors.

Ex: [1, 0, 0, 0] -> [0.1, 0.3, -0.2, 0.5, ..., 0.0] (10 dimensions)
    [0, 1, 0, 0] -> [0.4, -0.1, 0.2, 0.3, ..., 0.1] (10 dimensions)

Its a matrix multiplication by a matrix with orthogonal rows.

The null space is slack space, and the neural network can use that slack space to connect different inputs together.

### Ternary Representation

Ternary representation is similar to binary representation, but instead of using base 2, we use base 3.

We also have some freedom for coefficents, we could use [-1, 0, 1] or [0, 1, 2]. Both of these actually form a
valid base 3 representation.

Base 3 representation with negatives allows us to play around with negative numbers more easily.

### More Symbols

We could include a representation which has significant slack not just in its projection, but in its base representation.
We can do this by including an excess of coefficents.

For example for binary, we can use coefficients [-1, 0, 1]. Or [-2, -1, 0, 1, 2].

This gives us tons of representation slack in weird geometric ways.

### Coefficent to Symbol Mapping

Its not nessarily the case that each coefficent maps to its integer value as a symbol.

For example using ternerary with coefficents [0, 1, 2] you could send [0] to 0, [1] to -1, and [2] to 1.

## Overall General Representation

As an overall general parameterized representation:

Base (r): an integer r >= 2

Digits (d): number of digits

CoeffSet (C): A set of coefficients, We will parameterize it with an integer C_k and a boolean C_neg.
  If C_neg is true, then C = [-C_k, ..., -1, 0, 1, ..., C_k]
  If C_neg is false, then C = [0, 1, ..., C_k-1]

Any integer has some number of representations in this format, defined as a vector of length d.

c_0 + c_1 * r^1 + c_2 * r^2 + ... + c_(d-1) * r^(d-1)

Where each c_i is in C.

